use chrono::{NaiveDateTime, TimeZone, Utc};
use serde::{Deserialize, Serialize};


use ya_client::model::{market::Offer as ClientOffer, ErrorMessage, NodeId};
use ya_service_api_web::middleware::Identity;

use super::SubscriptionId;
use crate::db::model::subscription_id::SubscriptionValidationError;
use crate::db::schema::{market_offer, market_offer_unsubscribed};
use ya_client::model::market::NewOffer;

#[derive(Clone, Debug, Identifiable, Insertable, Queryable, Deserialize, Serialize)]
#[table_name = "market_offer"]
pub struct Offer {
    pub id: SubscriptionId,
    pub properties: String,
    pub constraints: String,
    pub node_id: NodeId,

    /// Creation time of Offer on Provider side.
    pub creation_ts: NaiveDateTime,
    /// Timestamp of adding this Offer to database.
    pub insertion_ts: Option<NaiveDateTime>,
    /// Time when Offer expires; set by Provider.
    pub expiration_ts: NaiveDateTime,
}

/// Keeps track of Offers, that were already unsubscribed.
/// We don't need to keep whole unsubscribed Offer, it is enough to keep it's
/// subscription id.
/// This entry must exist in database at least until Offer expiration time.
/// Otherwise we will add this Offer for the second time, when someone will bcast it.
#[derive(Clone, Debug, Identifiable, Insertable, Queryable)]
#[table_name = "market_offer_unsubscribed"]
pub struct OfferUnsubscribed {
    pub id: SubscriptionId,
    pub node_id: NodeId,

    /// Timestamp of adding unsubscribe mark to database.
    pub insertion_ts: Option<NaiveDateTime>,
    /// Time when unsubscribed Offer expires; set by Provider.
    pub expiration_ts: NaiveDateTime,
}

impl Offer {
    /// Creates new model offer. If ClientOffer has id already assigned,
    /// it will be ignored and regenerated.
    pub fn from_new(
        offer: &NewOffer,
        id: &Identity,
        creation_ts: NaiveDateTime,
        expiration_ts: NaiveDateTime,
    ) -> Result<Offer, serde_json::error::Error> {
        let properties = serde_json::to_string(&ya_agreement_utils::agreement::flatten(
            offer.properties.clone(),
        ))?;
        let constraints = offer.constraints.clone();
        let node_id = id.identity;

        // This function creates new Offer, so creation time should be generated by database.

        let id = SubscriptionId::generate_id(
            &properties,
            &constraints,
            &node_id,
            &creation_ts,
            &expiration_ts,
        );

        Ok(Offer {
            id,
            properties,
            constraints,
            node_id,
            creation_ts,
            insertion_ts: None, // Database will insert this timestamp.
            expiration_ts,
        })
    }

    pub fn into_client_offer(&self) -> Result<ClientOffer, ErrorMessage> {
        Ok(ClientOffer {
            offer_id: self.id.to_string(),
            provider_id: self.node_id.clone(),
            constraints: self.constraints.clone(),
            properties: serde_json::from_str(&self.properties).map_err(|e| {
                format!(
                    "Can't serialize Offer [{}] properties from database. Error: {}",
                    self.id, e
                )
            })?,
            timestamp: Utc.from_utc_datetime(&self.creation_ts),
        })
    }

    pub fn into_unsubscribe(self) -> OfferUnsubscribed {
        OfferUnsubscribed {
            id: self.id,
            node_id: self.node_id,
            insertion_ts: None,
            expiration_ts: self.expiration_ts,
        }
    }

    /// Will reject Offer, if hash was computed incorrectly. In most cases
    /// it could mean, that it could be some kind of attack.
    pub fn validate(&self) -> Result<(), SubscriptionValidationError> {
        self.id.validate(
            &self.properties,
            &self.constraints,
            &self.node_id,
            &self.creation_ts,
            &self.expiration_ts,
        )
    }
}

/// PartialEq implementation that ignores insertion_ts.
impl PartialEq for Offer {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
            && self.constraints == other.constraints
            && self.creation_ts == other.creation_ts
            && self.expiration_ts == other.expiration_ts
            && self.properties == other.properties
            && self.node_id == other.node_id
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{NaiveDate, NaiveTime};
    use std::str::FromStr;
    use ya_client::model::NodeId;

    #[test]
    // Offer with subscription id, that has wrong hash, should fail to create model.
    fn test_offer_validation_wrong_hash() {
        let false_subscription_id = "c76161077d0343ab85ac986eb5f6ea38-edb0016d9f8bafb54540da34f05a8d510de8114488f23916276bdead05509a53";
        let node_id = "0xbabe000000000000000000000000000000000000";

        let offer = Offer {
            id: SubscriptionId::from_str(false_subscription_id).unwrap(),
            properties: "{}".to_string(),
            constraints: "()".to_string(),
            node_id: NodeId::from_str(node_id).unwrap(),
            creation_ts: NaiveDateTime::new(
                NaiveDate::from_ymd(1970, 1, 1),
                NaiveTime::from_hms(0, 1, 1),
            ),
            insertion_ts: None,
            expiration_ts: NaiveDateTime::new(
                NaiveDate::from_ymd(1970, 1, 1),
                NaiveTime::from_hms(15, 1, 1),
            ),
        };
        assert!(offer.validate().is_err());
    }

    #[test]
    fn test_offer_validation_good_hash() {
        let offer_id = "c76161077d0343ab85ac986eb5f6ea38-85fdde1924371f4a3a412748f61e5b941c500ea69a55a5135b886a2bffcb8e55";
        let node_id = "0xbabe000000000000000000000000000000000000";

        let offer = Offer {
            id: SubscriptionId::from_str(offer_id).unwrap(),
            properties: "{}".to_string(),
            constraints: "()".to_string(),
            node_id: NodeId::from_str(node_id).unwrap(),
            creation_ts: NaiveDateTime::new(
                NaiveDate::from_ymd(1970, 1, 1),
                NaiveTime::from_hms(0, 1, 1),
            ),
            insertion_ts: None,
            expiration_ts: NaiveDateTime::new(
                NaiveDate::from_ymd(1970, 1, 1),
                NaiveTime::from_hms(15, 1, 1),
            ),
        };
        let id = SubscriptionId::generate_id(
            &offer.properties,
            &offer.constraints,
            &offer.node_id,
            &offer.creation_ts,
            &offer.expiration_ts,
        );
        println!("{}", id);

        offer.validate().unwrap();
    }

    // TODO: test from_new
}
