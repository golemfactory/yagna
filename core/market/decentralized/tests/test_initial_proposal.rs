mod utils;

#[cfg(test)]
mod tests {
    use ya_client::model::market::event::RequestorEvent;
    use ya_client::model::market::proposal::State;
    use ya_market_decentralized::testing::DraftProposal;
    use ya_market_decentralized::testing::SubscriptionId;
    use ya_market_decentralized::testing::{DemandDao, OfferDao};
    use ya_market_decentralized::MarketService;

    use crate::utils::mock_offer::{example_demand, example_offer};
    use crate::utils::MarketsNetwork;

    use std::str::FromStr;
    use std::sync::Arc;
    use std::time::Duration;

    /// Initial proposal generated by market should be available at
    /// query events endpoint.
    /// TODO: Rewrite this test to use proposals generated by matcher instead
    ///  of injecting them negotiation engine.
    #[cfg_attr(not(feature = "market-test-suite"), ignore)]
    #[actix_rt::test]
    async fn test_query_initial_proposal() -> Result<(), anyhow::Error> {
        env_logger::init();
        let network = MarketsNetwork::new("test_query_initial_proposal")
            .await
            .add_market_instance("Node-1")
            .await?;

        let market1: Arc<MarketService> = network.get_market("Node-1");
        let identity1 = network.get_default_id("Node-1");

        let subscription_id = market1
            .subscribe_demand(&example_demand(), identity1.clone())
            .await?;

        // We need model Offer. So we will get it from database.
        let offer_id = market1
            .subscribe_offer(&example_offer(), identity1.clone())
            .await?;

        // Get model Demand to directly inject it into negotiation engine.
        let db = network.get_database("Node-1");
        let model_demand = db
            .as_dao::<DemandDao>()
            .get_demand(&SubscriptionId::from_str(subscription_id.as_ref())?)
            .await?
            .unwrap();

        let model_offer = db
            .as_dao::<OfferDao>()
            .get_offer(&SubscriptionId::from_str(offer_id.as_ref())?)
            .await?
            .unwrap();

        let proposal = DraftProposal {
            offer: model_offer,
            demand: model_demand,
        };
        market1.matcher.emit_proposal(proposal)?;
        tokio::time::delay_for(Duration::from_millis(30)).await;

        // We expect that proposal will be available as event.
        let events = market1
            .requestor_engine
            .query_events(&subscription_id, 0.0, 1)
            .await?;

        assert_eq!(events.len(), 1);

        let proposal = match events[0].clone() {
            RequestorEvent::ProposalEvent { proposal, .. } => proposal,
            _ => panic!("Invalid event Type. ProposalEvent expected"),
        };

        assert_eq!(proposal.prev_proposal_id, None);
        assert_eq!(proposal.state()?, &State::Initial);

        Ok(())
    }
}
